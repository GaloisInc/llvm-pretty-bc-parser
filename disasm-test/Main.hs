{-# LANGUAGE DeriveDataTypeable #-}
{-# LANGUAGE RecordWildCards #-}
{-# LANGUAGE TypeApplications #-}

module Main where

import           Data.LLVM.BitCode (parseBitCodeLazyFromFile,Error(..),formatError)
import qualified Text.LLVM.AST as AST
import           Text.LLVM.PP (ppLLVM,ppModule)

import qualified Control.Exception as X
import           Control.Monad (when)
import qualified Data.ByteString.Lazy as L
import           Data.Char (ord,isSpace,chr)
import           Data.Generics (everywhere, mkT) -- SYB
import           Data.List (sort)
import           Data.Proxy ( Proxy(..) )
import           Data.Typeable (Typeable)
import qualified Options.Applicative as OA
import           System.Directory (getTemporaryDirectory, removeFile)
import           System.Exit (ExitCode(..))
import           System.FilePath ((<.>))
import           System.IO
    (openBinaryTempFile,hClose,openTempFile,hPutStrLn)
import qualified System.Process as Proc
import           Test.Tasty
import           Test.Tasty.HUnit ( assertFailure, testCase )
import qualified Test.Tasty.Options as TO
import qualified Test.Tasty.Runners as TR
import qualified Test.Tasty.Sugar as TS
import           Text.Show.Pretty (ppShow)


-- Option Parsing --------------------------------------------------------------

newtype LLVMAs = LLVMAs FilePath

instance TO.IsOption LLVMAs where
  defaultValue = LLVMAs "llvm-as"
  parseValue = Just . LLVMAs
  optionName = pure "with-llvm-as"
  optionHelp = pure "path to llvm-as"
  showDefaultValue (LLVMAs as) = Just as
  optionCLParser = TO.mkOptionCLParser $
    OA.metavar "FILEPATH"

newtype LLVMDis = LLVMDis FilePath

instance TO.IsOption LLVMDis where
  defaultValue = LLVMDis "llvm-dis"
  parseValue = Just . LLVMDis
  optionName = pure "with-llvm-dis"
  optionHelp = pure "path to llvm-dis"
  showDefaultValue (LLVMDis dis) = Just dis
  optionCLParser = TO.mkOptionCLParser $
    OA.metavar "FILEPATH"

newtype Roundtrip = Roundtrip Bool

instance TO.IsOption Roundtrip where
  defaultValue = Roundtrip True
  parseValue = fmap Roundtrip . TO.safeReadBool
  optionName = pure "roundtrip"
  optionHelp = pure "disable roundtrip tests (AST/AST diff)"
  showDefaultValue (Roundtrip r) = Just $ show r
  optionCLParser = TO.mkOptionCLParser $
    OA.short 'r'

newtype Keep = Keep Bool

instance TO.IsOption Keep where
  defaultValue = Keep False
  parseValue = fmap Keep . TO.safeReadBool
  optionName = pure "keep"
  optionHelp = pure "keep all generated files for manual inspection"
  showDefaultValue (Keep k) = Just $ show k
  optionCLParser = TO.mkOptionCLParser $
    OA.short 'k'

disasmTestIngredients :: [TR.Ingredient]
disasmTestIngredients =
  includingOptions [ TO.Option (Proxy @LLVMAs)
                   , TO.Option (Proxy @LLVMDis)
                   , TO.Option (Proxy @Roundtrip)
                   , TO.Option (Proxy @Keep)
                   ] :
  defaultIngredients

-- Test Running ----------------------------------------------------------------

-- | Run all provided tests.
main :: IO ()
main =  do
  sweets <- TS.findSugar cube
  tests <- TS.withSugarGroups sweets testGroup $ \s _ e -> runTest s e
  defaultMainWithIngredients disasmTestIngredients $
    testGroup "Disassembly tests" tests

cube :: TS.CUBE
cube = TS.mkCUBE
  { TS.inputDirs = ["disasm-test/tests"]
  , TS.rootName = "*.ll"
  , TS.separators = "."
    -- Somewhat unusually for tasty-sugar, we make the expectedSuffix the same
    -- as the rootName suffix. This is because we are comparing the contents of
    -- each .ll file against *itself* after parsing it with
    -- llvm-pretty-bc-parser, pretty-printing it with llvm-pretty, and
    -- then normalizing it. As such, each .ll file acts as its own golden file.
  , TS.expectedSuffix = "ll"
  }

-- | A test failure.
data TestFailure
  = ParseError Error -- ^ A parser failure.
    deriving (Typeable,Show)

instance X.Exception TestFailure

-- | Attempt to compare the assembly generated by llvm-pretty and llvm-dis.
runTest :: TS.Sweets -> TS.Expectation -> IO [TestTree]
runTest sweet _expct =
  pure $ (:[]) $
  askOption $ \llvmAs ->
  askOption $ \llvmDis ->
  askOption $ \roundtrip ->
  askOption $ \k@(Keep keep) ->
  testCase pfx $ do

    let -- Assemble and disassemble some LLVM asm
        processLL :: FilePath -> IO (FilePath, Maybe FilePath)
        processLL f = do
          putStrLn (showString f ": ")
          X.handle logError                               $
            withFile  (generateBitCode    llvmAs  pfx f)  $ \ bc   ->
            withFile  (normalizeBitCode k llvmDis pfx bc) $ \ norm -> do
              (parsed, ast) <- processBitCode k roundtrip pfx bc
              ignore (Proc.callProcess "diff" ["-u", norm, parsed])
              putStrLn ("successfully parsed " ++ show f)
              return (parsed, ast)

        withFile :: IO FilePath -> (FilePath -> IO r) -> IO r
        withFile iofile f =
          X.bracket iofile (if keep then const (pure ()) else removeFile) f

    (parsed1, ast) <- processLL file
    case ast of               -- this Maybe also encodes the data of optRoundtrip
      Nothing   -> return ()
      Just ast1 -> do
        (_, Just ast2) <- processLL parsed1 -- Re-assemble and re-disassemble
        diff ast1 ast2                      -- Ensure that the ASTs match
        -- Ensure that the disassembled files match.
        -- This is usually too strict (and doesn't really provide more info).
        -- We normalize the AST (see below) to ensure that the ASTs match modulo
        -- metadata numbering, but the equivalent isn't possible for the
        -- assembly: we need llvm-as to be able to re-assemble it.
        -- diff parsed1 parsed2
  where file  = TS.rootFile sweet
        pfx   = TS.rootBaseName sweet
        assertF ls = assertFailure $ unlines ls
        logError (ParseError msg) =
          assertFailure $ unlines $
            "failure" : map ("; " ++) (lines (formatError msg))
        diff file1 file2 = do
          (code, stdout, stderr) <-
            Proc.readCreateProcessWithExitCode (Proc.proc "diff" ["-u", file1, file2]) ""
          case code of
            ExitFailure _ -> assertF ["diff failed", stdout, stderr]
            ExitSuccess   ->
              if stdout /= "" || stderr /= ""
              then assertF ["non-empty diff", stdout, stderr]
              else mapM_ putStrLn ["success: empty diff: ", file1, file2]

-- | Assemble some llvm assembly, producing a bitcode file in /tmp.
generateBitCode :: LLVMAs -> FilePath -> FilePath -> IO FilePath
generateBitCode (LLVMAs llvmAs) pfx file = do
  tmp    <- getTemporaryDirectory
  (bc,h) <- openBinaryTempFile tmp (pfx <.> "bc")
  hClose h
  callProc llvmAs ["-o", bc, file]
  return bc

-- | Use llvm-dis to parse a bitcode file, to obtain a normalized version of the
-- llvm assembly.
normalizeBitCode :: Keep -> LLVMDis -> FilePath -> FilePath -> IO FilePath
normalizeBitCode _keep (LLVMDis llvmDis) pfx file = do
  tmp      <- getTemporaryDirectory
  (norm,h) <- openTempFile tmp (pfx ++ "llvm-dis" <.> "ll")
  hClose h
  callProc llvmDis ["-o", norm, file]
  -- stripComments _keep norm
  return norm

-- | Usually, the ASTs aren't "on the nose" identical.
-- The big thing is that the metadata numbering differs, so we zero out all
-- metadata indices and sort the unnamed metadata list.
-- Done with SYB (Scrap Your Boilerplate).
normalizeModule :: AST.Module -> AST.Module
normalizeModule = sorted . everywhere (mkT zeroValMdRef)
                         . everywhere (mkT zeroNamedMd)
  where sorted m = m { AST.modUnnamedMd =
                         sort (map (\um -> um { AST.umIndex = 0 })
                                   (AST.modUnnamedMd m)) }
        -- Zero out all ValMdRefs
        zeroValMdRef (AST.ValMdRef _) = AST.ValMdRef 0
        zeroValMdRef a                = (a :: AST.ValMd) -- avoid ambiguous type

        -- Reduce all named metadata
        zeroNamedMd (AST.NamedMd x _) = AST.NamedMd x []


-- | Parse a bitcode file using llvm-pretty, failing the test if the parser
-- fails.
processBitCode :: Keep -> Roundtrip -> FilePath -> FilePath -> IO (FilePath, Maybe FilePath)
processBitCode _keep (Roundtrip roundtrip) pfx file = do
  let handler :: X.SomeException -> IO (Either Error AST.Module)
      handler se = return (Left (Error [] (show se)))
      printToTempFile sufx stuff = do
        tmp        <- getTemporaryDirectory
        (parsed,h) <- openTempFile tmp (pfx ++ "llvm-disasm" <.> sufx)
        hPutStrLn h stuff
        hClose h
        return parsed
  e <- parseBitCodeLazyFromFile file `X.catch` handler
  case e of
    Left err -> X.throwIO (ParseError err)
    Right m  -> do
      parsed <- printToTempFile "ll" (show (ppLLVM (ppModule m)))
      -- stripComments _keep parsed
      if roundtrip
      then do
        tmp2 <- printToTempFile "ast" (ppShow (normalizeModule m))
        return (parsed, Just tmp2)
      else return (parsed, Nothing)

-- | Remove comments from a .ll file, stripping everything including the
-- semi-colon.
stripComments :: Keep -> FilePath -> IO ()
stripComments (Keep keep) path = do
  bytes <- L.readFile path
  when (not keep) (removeFile path)
  mapM_ (writeLine . dropComments) (bsLines bytes)
  where
  writeLine bs | L.null bs = return ()
               | otherwise = do
                 L.appendFile path bs
                 L.appendFile path (L.singleton 0x0a)

-- | Split a bytestring by its lines.
bsLines :: L.ByteString -> [L.ByteString]
bsLines = L.split char
  where
  char = fromIntegral (ord '\n')

-- | Take characters until the llvm comment delimiter is found.
dropComments :: L.ByteString -> L.ByteString
dropComments  = dropTrailingSpace . L.takeWhile (/= char)
  where
  char = fromIntegral (ord ';')

-- | Drop trailing space from a bytestring.
dropTrailingSpace :: L.ByteString -> L.ByteString
dropTrailingSpace bs
  | len <= 0  = L.empty
  | otherwise = L.take (loop len) bs
  where
  len = L.length bs - 1
  loop n | isSpace (chr (fromIntegral (L.index bs n))) = loop (n-1)
         | otherwise                                   = n

-- | Ignore a command that fails.
ignore :: IO () -> IO ()
ignore  = X.handle f
  where f   :: X.IOException -> IO ()
        f _ = return ()

callProc :: String -> [String] -> IO ()
callProc p args = -- putStrLn ("Calling process: " ++ p ++ " " ++ unwords args) >>
  Proc.callProcess p args
